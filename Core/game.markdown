- [Game（游戏相关）](#game游戏相关)
  - [Vertical Sync（垂直同步）](#vertical-sync垂直同步)
  - [图片信息](#图片信息)
    - [宽度](#宽度)
    - [高度](#高度)
    - [水平分辨率（dpi）](#水平分辨率dpi)
    - [垂直分辨率（dpi）](#垂直分辨率dpi)
    - [位深度](#位深度)
    - [大小](#大小)
  - [显示动态范围](#显示动态范围)
    - [SDR（标准动态范围）](#sdr标准动态范围)
    - [HDR（高动态范围）](#hdr高动态范围)
    - [Tonemapping（色度映射算法）](#tonemapping色度映射算法)
  - [Video（视频）](#video视频)
    - [Video Caption（视频字幕）](#video-caption视频字幕)
      - [嵌入类型](#嵌入类型)
        - [硬字幕](#硬字幕)
        - [软字幕](#软字幕)
        - [外挂字幕](#外挂字幕)
      - [字幕类型](#字幕类型)
        - [srt](#srt)
  - [Mipmap（逐级缩略纹理）](#mipmap逐级缩略纹理)
    - [定义](#定义)
    - [实现](#实现)
    - [优点](#优点)
    - [缺点](#缺点)
  - [Texture Filter Mode（纹理过滤）](#texture-filter-mode纹理过滤)
    - [纹素](#纹素)
    - [像素](#像素)
    - [Nearest Point Sampling（临近点采样）](#nearest-point-sampling临近点采样)
    - [Bilinear（双线性过滤）](#bilinear双线性过滤)
    - [Trilinear（三线性过滤）](#trilinear三线性过滤)
    - [Anisotropic Filtering（各向异性过滤）](#anisotropic-filtering各向异性过滤)
    - [优点](#优点-1)
    - [缺点](#缺点-1)
  - [抗锯齿（Anti-Aliasing）](#抗锯齿anti-aliasing)
    - [锯齿（Aliasing）](#锯齿aliasing)
    - [SSAA（Super Sampling Anti-Aliasing 超级采样抗锯齿）](#ssaasuper-sampling-anti-aliasing-超级采样抗锯齿)
      - [实现](#实现-1)
      - [优点](#优点-2)
      - [缺点](#缺点-2)
    - [MSAA（Multi Sampling Anti-Aliasing 多重采样抗锯齿）](#msaamulti-sampling-anti-aliasing-多重采样抗锯齿)
      - [实现](#实现-2)
      - [优点](#优点-3)
      - [缺点](#缺点-3)
    - [TAA（Temporal Anti-Aliasing 时域抗锯齿）](#taatemporal-anti-aliasing-时域抗锯齿)
      - [实现](#实现-3)
      - [优点](#优点-4)
      - [缺点](#缺点-4)
    - [FXAA（Fast Approximate Anti-Aliaing 快速近似抗锯齿）](#fxaafast-approximate-anti-aliaing-快速近似抗锯齿)
  - [颜色空间（Linear Space \&\& Gamma Space）](#颜色空间linear-space--gamma-space)
    - [伽马校正](#伽马校正)
    - [sRGB](#srgb)
    - [Linear Space（线性空间）](#linear-space线性空间)
    - [Gamma Space（伽马空间）](#gamma-space伽马空间)
    - [结论](#结论)
    - [Unity内的色彩空间](#unity内的色彩空间)
      - [空间选项](#空间选项)
      - [输入图选项](#输入图选项)
      - [其余](#其余)


# Game（游戏相关）

## Vertical Sync（垂直同步）
对屏幕画面刷新的频率制约
不开启垂直同步，显卡和显示器不会受到频率制约，当一屏画面绘制完成后，立刻开始绘制下一屏。这样可能导致
当前画面还未显示完全，就被下一屏画面所覆盖（画面显示是逐行或逐列进行逐像素填充），导致画面产生"撕裂"
开启垂直同步，显卡和显示器会受到频率制约，当垂直同步信号到达后（eg.80HZ），才会进行下一屏绘制，保证
屏幕的顺滑稳定
![alt text](assets/game/image-7.png)

## 图片信息
![Alt text](assets/game/image-1.png)
### 宽度
图片横轴像素总数，如上图为1600像素
### 高度
图片竖轴像素总数，如上图为960像素
### 水平分辨率（dpi）
图片每英寸宽度包含的像素总数
### 垂直分辨率（dpi）
图片每英寸长度包含的像素总数
### 位深度
图片中每个像素占据的位数，如上图为24位也就是3字节(byte)
### 大小
原始图片的大小（未压缩），横轴像素总和x竖轴像素总和x位深度（由于计算机的显示单位一般为字节，所以位深度需要除以8）。如上图则为，1600*960*(24/8) = 4608000B = 4608000/1024 = 4500KB = 4500/1024 = 4.39MB。
至于上图显示的实际大小和计算上不同是因为图片已经<font color=#FF0000>压缩过了</font>

## 显示动态范围

### SDR（标准动态范围）
图像的亮度和色彩范围较低，视觉效果一般
亮度一般为100-300尼特
色彩深度一般只限于8位，即RGB区间为0-255

### HDR（高动态范围）
图像的亮度和色彩显著高于SDR，视觉效果较好
亮度可达到1000-10000尼特，白色更亮，黑色更深
色彩深度可以达到10位甚至12位，即RGB区间为0-1024到0-4096

### Tonemapping（色度映射算法）
当原图为HDR但设备只能显示SDR时，将HDR转换成SDR，并尽量多保留细节保证图像不失真的算法

## Video（视频）

### Video Caption（视频字幕）

#### 嵌入类型
嵌入视频的字幕一般分为3种，硬字幕，软字幕，外挂字幕

##### 硬字幕
将字幕嵌入视频中，变为视频图片的一部分，嵌入后只剩一个视频文件。用户无法用播放工具来开启/隐藏字幕。要提取或消去字幕非常麻烦，需要的话可以使用软件"esrXP"操作 [如何提取视频中的硬字幕?](https://zhuanlan.zhihu.com/p/66963890?utm_id=0) 

##### 软字幕
作为视频轨道嵌入视频内。这种视频格式为"MKV"。可以使用软件提取编辑字幕

##### 外挂字幕
字幕文件和视频文件独立分开。播放时，播放器会检测当前目录是否存在和视频文件同名的字幕文件（常用的如.srt）,有的话会读取字幕文件并在播放视频时展现。可以在播放器设置字幕显隐颜色及大小

#### 字幕类型

##### srt
[srt字幕的认识和入门使用](https://www.bilibili.com/read/cv35373911/?jump_opus=1) 
常用的外挂字幕格式</br>
内部格式为索引——开始时间——结束时间——内容</br>
```
1
00:00:00,000 --> 00:00:02,010
你好啊~~~

2
00:00:02,020 --> 00:00:05,030
早中晚上好哈喽~~~

1
00:00:00,000 --> 00:00:03,010
Ohhhh~~~

2
00:00:03,020 --> 00:00:05,030
Hellooooooo~~~
```
![Alt text](assets/game/image-2.png)</br>

需要和视频文件取相同的名称，并存放在同级目录下，播放时才能自动载入（如视频文件为abc.mp4 则字幕文件为abc.srt）

## Mipmap（逐级缩略纹理）
### 定义
Mipmap是种对原始纹理产出逐级缩略图的技术
每次产生缩略图的大小为原始纹理长宽各除以2，也就是总大小除以4，最后直到长宽各为1时终止
例：
原始图为256x256，使用mipmap最终会生成128x128，64x64，32x32，16x16，8x8，4x4，2x2，1x1 共计8张缩略图
### 实现
缩略图的纹素是采样原图纹素后做均值得来的
例：
128x128的缩略图位置(0,0)，是采样256x256缩略图(0,0),(0,1),(1,0),(1,1)这4个位置的纹素混合并取得均值得到的
### 优点
可以根据屏幕显示的像素大小获取更接近大小的纹理，以此减少加载纹理时的带宽需求，并可适用于多种纹理过滤
### 缺点
生成的各级缩略图会多占用33%的内存空间

## Texture Filter Mode（纹理过滤）
将纹理映射到不同分辨率的方法

### 纹素
纹理贴图的最小单位，实际显示的时候需要将其转换为像素

### 像素
屏幕显示的最小单位，也就是分辨率的单位。如屏幕分辨率1280x720意思是水平有1280个像素，垂直有720个像素

### Nearest Point Sampling（临近点采样）
直接在像素点上采样相对位置的纹素信息

优点
快捷
当显示对象表面和纹理图大小相近时，效果不错

缺点
当显示对象表面和纹理图大小有一定差别时，有可能变形，效果不佳

### Bilinear（双线性过滤）
1.选取最接近屏幕显示对象大小（像素大小）的纹理（如开启Mipmap）
2.对每个像素进行采样（映射到对应纹素位置），获取映射到的纹素位置周边（上下左右）的4个纹素值
3.最后取线性插值作为该像素最终的采样值

优点
大多数情况都能产生较优效果，尤其是开启Mipmap后

缺点
需要一定计算量

### Trilinear（三线性过滤）
选取最接近屏幕显示对象大小的前后2张纹理，分别对其执行双线性过滤操作后，对2个采样后的值再做一次线性插值得出最终值
未产生多张不同大小的纹理时（如未开启Mipmap），Trilinear和Bilinear得到的效果一致

优点
一般效果会更优于Bilinear

缺点
计算量会大于Bilinear

### Anisotropic Filtering（各向异性过滤）
针对屏幕显示对象为非正方形时过滤采样
之前的同性过滤基本都是基于对象为正方形，但是当采样长宽比不为1:1时，效果容易失真
异性过滤会考虑显示区域与纹理间的角度，按长宽比例对不同方向采样不同数量的纹素，以此得出最终值
目前显卡最多支持Anisotropic Filtering 16X
### 优点
在采样对象非方形时，效果优于同性过滤
### 缺点
有一定的性能消耗

## 抗锯齿（Anti-Aliasing）

### 锯齿（Aliasing）
屏幕可视物体出现锯齿状边缘的原因是位于物体边缘的像素有部分没被渲染，导致边缘颜色看起来不齐整就像锯齿一般
屏幕分辨率越低锯齿会越明显。因为低分辨率下（屏幕像素总量低）物体占用的像素少，这时边缘像素若不被渲染看起来就很明显。例如占用5个像素的物体缺少了1个边缘像素渲染整体就少了1/5（看起来很明显），而占用50个像素的物体少了1个边缘像素的渲染只少了1/50（看起来就不那么明显）
一个像素是否被渲染取决于像素中心的位置是否被物体覆盖，而物体边缘若是斜线或多重线段组合，必然会出现边缘像素中心覆盖不均衡因而产生锯齿

### SSAA（Super Sampling Anti-Aliasing 超级采样抗锯齿）
#### 实现
1.通过生成一张数倍于当前屏幕分辨率大小的贴图，在每个原像素点区域内再划分出若干个次像素点。例如4x SSAA意为着生成一张4倍屏幕分辨率的贴图，原本的1个像素点的区域会被划分为4个次像素点的区域
2.对每个次像素点进行采样着色
3.将像素点内的所有次像素点颜色进行混合，计算得出对应像素点的最终颜色
#### 优点
相当于提高屏幕本身分辨率，抗锯齿效果会很好
#### 缺点
大贴图会增加内存消耗
增加数倍采样次数会大幅度增加性能消耗
![alt text](assets/game/image-8.png)

### MSAA（Multi Sampling Anti-Aliasing 多重采样抗锯齿）
[主流抗锯齿方案详解（一）MSAA]https://zhuanlan.zhihu.com/p/415087003
#### 实现
1.和SSAA一样，会生成一张大分辨率贴图与次像素点
2.对每个次像素点执行覆盖测试，找出所有被物体覆盖的次像素点
3.对首个次像素点进行采样。若物体覆盖了像素中心点，则对像素中心点进行采样，若没覆盖像素中心点，则对当前次像素点的中心进行采样，记录采样结果的颜色
4.对次像素点进行深度测试和模板测试，当次像素点通过测试后，将上一步记录的采样结果赋予它（保存在生成的贴图内）
5.将像素点内生成的所有次像素点颜色混合，获取对应像素的最终颜色
![alt text](assets/game/image-9.png)
#### 优点
1.比起SSAA，单个像素点内不论次像素点的数量多少都只需采样一次，大幅减少采样计算消耗
#### 缺点
1.根据次像素点数量所生成的贴图大幅增加内存消耗
2.虽然每个像素点只需要采样一次，但要进行覆盖测试，并计算次像素点颜色需要采样的位置。此外每个次像素点都要执行固定计算流程（例如深度测试/模板测试），一样会比正常采样多出数倍消耗

### TAA（Temporal Anti-Aliasing 时域抗锯齿）
[主流抗锯齿方案详解（二）TAA]https://zhuanlan.zhihu.com/p/425233743
#### 实现
1.在像素内生成多个次像素点
2.每帧按顺序在不同的次像素点上采样，将采样结果和上一帧的像素颜色进行混合
#### 优点
每帧只采样一次，比起其他抗锯齿方式计算消耗大幅度减少
#### 缺点
物体移动时，像素上覆盖的物体可能会一直变化，会导致像素颜色问题（混合了多个不同物体的颜色）

### FXAA（Fast Approximate Anti-Aliaing 快速近似抗锯齿）
[主流抗锯齿方案详解（三）FXAA]https://zhuanlan.zhihu.com/p/431384101

## 颜色空间（Linear Space && Gamma Space）
[Gamma、Linear、sRGB 和Unity Color Space，你真懂了吗](https://zhuanlan.zhihu.com/p/66558476)
现实世界中，光的强度和亮度是呈1:1正比的线性关系。但是在显示屏幕中，电压的强度和实际显示的亮度却是呈
1:2.2次幂的非线性关系。也就是说如果不做任何调整，人眼从屏幕看到的图像整体会偏暗

下左为现实输出 下右为屏幕输出
![alt text](assets/game/image-3.png)

### 伽马校正
为了让屏幕输出和现实世界一样，在屏幕输出前做的一个反2.2次幂（约0.45次幂）运算

### sRGB
也可以称作Gamma0.45空间，对空间内图像执行了一次伽马校正的色彩空间。例如：相机就是处于sRGB，相机保存拍摄图像时会自动执行一次伽马校正，这样从相机屏幕看到的图像就和现实世界看到的一样了

### Linear Space（线性空间）
1.将输入图像转为真实线性值（最终人眼看到的等同于现实世界的颜色值）。如果图像存在于sRGB空间中，会移除伽马校正，否则的话，不做操作
2.执行Shader等图形计算（转为线性值后计算出的结果更真实，因为图形计算都是依照真实世界的颜色值来设计的）
3.将计算后的最终结果做一次伽马校正
4.在屏幕上输出图像

### Gamma Space（伽马空间）
1.不对输入做任何操作
2.执行Shader等图形计算（因为输入可能不是线性值，所以计算结果和实际预想的可能会有偏差）
3.直接输出最终结果（由于没执行伽马校正，结果和现实世界可能会有差别）

### 结论
线性空间效果更真实，伽马空间消耗更小（少了中间计算）
如果更追求效果则使用线性空间，如果不那么追求可以使用伽马空间

### Unity内的色彩空间

#### 空间选项
可以在ProjectSetting内设置切换
![alt text](assets/game/image-4.png)

#### 输入图选项
有些图片默认就处在线性空间（比如只用于程序计算而不是让人眼观看的图 噪声纹理、法线纹理等），而有些则可以
通过sRGB选项来标明是否处于sRGB，被标明的图片在参与Shader计算时（纹理采样），Unity会移除伽马校正，反之则不会
![alt text](assets/game/image-5.png)

#### 其余
除了图片外，输入Shader的颜色也会被执行移除伽马校正的操作
对声明属性使用[Gamma]也可以被执行移除伽马校正的操作
![alt text](assets/game/image-6.png)